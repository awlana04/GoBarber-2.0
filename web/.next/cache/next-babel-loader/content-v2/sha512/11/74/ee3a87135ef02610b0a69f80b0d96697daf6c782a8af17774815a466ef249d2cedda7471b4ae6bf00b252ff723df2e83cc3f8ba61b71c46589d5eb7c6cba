{"ast":null,"code":"import { objectType, nonNull, stringArg } from 'nexus';\nimport { compare, hash } from 'bcryptjs';\nimport { sign } from 'jsonwebtoken';\nexport const Mutation = objectType({\n  name: 'Mutation',\n\n  definition(t) {\n    t.field('signup', {\n      type: 'AuthPayload',\n      args: {\n        email: nonNull(stringArg()),\n        password: nonNull(stringArg())\n      },\n      resolve: async (_parent, {\n        email,\n        password\n      }, context) => {\n        const hashedPassword = await hash(password, 10);\n        const user = await context.prisma.user.create({\n          data: {\n            email: email,\n            password: hashedPassword\n          }\n        });\n        return {\n          token: sign({\n            userId: user.id\n          }, process.env.APP_SECRET),\n          user\n        };\n      }\n    });\n    t.field('signin', {\n      type: 'AuthPayload',\n      args: {\n        email: nonNull(stringArg()),\n        password: nonNull(stringArg())\n      },\n      resolve: async (_parent, {\n        email,\n        password\n      }, context) => {\n        const user = await context.prisma.user.findUnique({\n          where: {\n            email\n          }\n        });\n\n        if (!user) {\n          throw new Error(`No user found for email: ${email}`);\n        }\n\n        const passwordValid = await compare(password, user.password);\n\n        if (!passwordValid) {\n          throw new Error('Invalid password');\n        }\n\n        return {\n          token: sign({\n            userId: user.id\n          }, process.env.APP),\n          user\n        };\n      }\n    });\n  }\n\n});","map":{"version":3,"sources":["/home/lon1/Documents/scripts/www/GoBarber-2.0/web/src/pages/api/nexus/resolvers/Mutation.ts"],"names":["objectType","nonNull","stringArg","compare","hash","sign","Mutation","name","definition","t","field","type","args","email","password","resolve","_parent","context","hashedPassword","user","prisma","create","data","token","userId","id","process","env","APP_SECRET","findUnique","where","Error","passwordValid","APP"],"mappings":"AAAA,SAASA,UAAT,EAAqBC,OAArB,EAA8BC,SAA9B,QAA+C,OAA/C;AACA,SAASC,OAAT,EAAkBC,IAAlB,QAA8B,UAA9B;AACA,SAASC,IAAT,QAAqB,cAArB;AAKA,OAAO,MAAMC,QAAQ,GAAGN,UAAU,CAAC;AACjCO,EAAAA,IAAI,EAAE,UAD2B;;AAEjCC,EAAAA,UAAU,CAACC,CAAD,EAAI;AACZA,IAAAA,CAAC,CAACC,KAAF,CAAQ,QAAR,EAAkB;AAChBC,MAAAA,IAAI,EAAE,aADU;AAEhBC,MAAAA,IAAI,EAAE;AACJC,QAAAA,KAAK,EAAEZ,OAAO,CAACC,SAAS,EAAV,CADV;AAEJY,QAAAA,QAAQ,EAAEb,OAAO,CAACC,SAAS,EAAV;AAFb,OAFU;AAMhBa,MAAAA,OAAO,EAAE,OAAOC,OAAP,EAAgB;AAAEH,QAAAA,KAAF;AAASC,QAAAA;AAAT,OAAhB,EAAqCG,OAArC,KAA0D;AACjE,cAAMC,cAAc,GAAG,MAAMd,IAAI,CAACU,QAAD,EAAW,EAAX,CAAjC;AAEA,cAAMK,IAAI,GAAG,MAAMF,OAAO,CAACG,MAAR,CAAeD,IAAf,CAAoBE,MAApB,CAA2B;AAC5CC,UAAAA,IAAI,EAAE;AACJT,YAAAA,KAAK,EAAEA,KADH;AAEJC,YAAAA,QAAQ,EAAEI;AAFN;AADsC,SAA3B,CAAnB;AAOA,eAAO;AACLK,UAAAA,KAAK,EAAElB,IAAI,CAAC;AAAEmB,YAAAA,MAAM,EAAEL,IAAI,CAACM;AAAf,WAAD,EAAsBC,OAAO,CAACC,GAAR,CAAYC,UAAlC,CADN;AAELT,UAAAA;AAFK,SAAP;AAID;AApBe,KAAlB;AAuBAV,IAAAA,CAAC,CAACC,KAAF,CAAQ,QAAR,EAAkB;AAChBC,MAAAA,IAAI,EAAE,aADU;AAEhBC,MAAAA,IAAI,EAAE;AACJC,QAAAA,KAAK,EAAEZ,OAAO,CAACC,SAAS,EAAV,CADV;AAEJY,QAAAA,QAAQ,EAAEb,OAAO,CAACC,SAAS,EAAV;AAFb,OAFU;AAMhBa,MAAAA,OAAO,EAAE,OAAOC,OAAP,EAAgB;AAAEH,QAAAA,KAAF;AAASC,QAAAA;AAAT,OAAhB,EAAqCG,OAArC,KAA0D;AACjE,cAAME,IAAI,GAAG,MAAMF,OAAO,CAACG,MAAR,CAAeD,IAAf,CAAoBU,UAApB,CAA+B;AAChDC,UAAAA,KAAK,EAAE;AACLjB,YAAAA;AADK;AADyC,SAA/B,CAAnB;;AAMA,YAAI,CAACM,IAAL,EAAW;AACT,gBAAM,IAAIY,KAAJ,CAAW,4BAA2BlB,KAAM,EAA5C,CAAN;AACD;;AAED,cAAMmB,aAAa,GAAG,MAAM7B,OAAO,CAACW,QAAD,EAAWK,IAAI,CAACL,QAAhB,CAAnC;;AAEA,YAAI,CAACkB,aAAL,EAAoB;AAClB,gBAAM,IAAID,KAAJ,CAAU,kBAAV,CAAN;AACD;;AAED,eAAO;AACLR,UAAAA,KAAK,EAAElB,IAAI,CAAC;AAAEmB,YAAAA,MAAM,EAAEL,IAAI,CAACM;AAAf,WAAD,EAAsBC,OAAO,CAACC,GAAR,CAAYM,GAAlC,CADN;AAELd,UAAAA;AAFK,SAAP;AAID;AA3Be,KAAlB;AA6BD;;AAvDgC,CAAD,CAA3B","sourcesContent":["import { objectType, nonNull, stringArg } from 'nexus';\nimport { compare, hash } from 'bcryptjs';\nimport { sign } from 'jsonwebtoken';\n\nimport { Context } from '../../context';\nimport { getUserId } from '../../utils/getUserId';\n\nexport const Mutation = objectType({\n  name: 'Mutation',\n  definition(t) {\n    t.field('signup', {\n      type: 'AuthPayload',\n      args: {\n        email: nonNull(stringArg()),\n        password: nonNull(stringArg()),\n      },\n      resolve: async (_parent, { email, password }, context: Context) => {\n        const hashedPassword = await hash(password, 10);\n\n        const user = await context.prisma.user.create({\n          data: {\n            email: email,\n            password: hashedPassword,\n          },\n        })\n\n        return {\n          token: sign({ userId: user.id }, process.env.APP_SECRET as string),\n          user,\n        }\n      },\n    })\n\n    t.field('signin', {\n      type: 'AuthPayload',\n      args: {\n        email: nonNull(stringArg()),\n        password: nonNull(stringArg()),\n      },\n      resolve: async (_parent, { email, password }, context: Context) => {\n        const user = await context.prisma.user.findUnique({\n          where: {\n            email\n          }\n        })\n\n        if (!user) {\n          throw new Error(`No user found for email: ${email}`);\n        }\n\n        const passwordValid = await compare(password, user.password);\n\n        if (!passwordValid) {\n          throw new Error('Invalid password');\n        }\n\n        return {\n          token: sign({ userId: user.id }, process.env.APP),\n          user,\n        }\n      }\n    })\n  }\n})\n"]},"metadata":{},"sourceType":"module"}